/**
 * @file	hal-m010.c
 * @author	Florian Hinterleitner
 * @date	08.01.2023
 * @brief	provides access to all digital IOs
 *
 */
// #include "hal-m010.h"
#include "globals.h"
#include "stm32f1xx.h"
#include "stdbool.h"
#include "hal-m010.h"
// #include "debugUnit.h"

// #define EXTI_BOOL

	#define GPIO_CRL_MODEx_0(x) (0x1U << (x * 4U))
	#define GPIO_CRL_MODEx_1(x) (0x2U << (x * 4U))
	#define GPIO_CRL_CNFx_0(x) (0x1U << (2U + x*4U))
	#define GPIO_CRL_CNFx_1(x) (0x2U << (2U + x*4U))

	#define GPIO_CRH_MODEx_0(x)	(0x1U << ( (x-8)* 4U))
	#define GPIO_CRH_MODEx_1(x)	(0x2U << ( (x-8)* 4U))
	#define GPIO_CRH_CNFx_0(x)	(0x1U << (2U + (x-8)*4U))
	#define GPIO_CRH_CNFx_1(x)	(0x2U << (2U + (x-8)*4U))

#define EXTI_IMR_MRx(x)	(0x1U << x)
#define EXTI_RTSR_TRx(x)	(0x1U << x)
#define EXTI_FTSR_TRx(x)	(0x1U << x)
#define MAX_DAC_VAL			( 4096-1  )
#define MIN_DAC_VOLT		-10.000
#define MAX_DAC_VOLT		10.000

// A8 = BUTT0
// B5 = BUTT1
//	(pin 81)	P A 9	STATE0
//	(pin 82) 	P A 10	STATE1
//	(pin 83) 	P A 8	BUTT0
//	(pin 84) 	P B 5	BUTT1


#ifdef EXTI_BOOL
	static bool risingEdges[MAX_EXTI_CNT];
	static bool fallingEdges[MAX_EXTI_CNT];

	bool getRisingEdge(int extiIdx)		{    return risingEdges[extiIdx];}
	bool getFallingEdge(int extiIdx)	{    return fallingEdges[extiIdx];}
	void setRisingEdges(int extiIdx)		{	risingEdges[extiIdx] = true;	}
	void setFallingEdges(int extiIdx)	{	fallingEdges[extiIdx] = true;	}
	void clrRisingEdges(int extiIdx)		{	risingEdges[extiIdx] = false;	}
	void clrFallingEdges(int extiIdx)	{	fallingEdges[extiIdx] = false;	}
#endif //  EXTI_BOOL
#ifndef  EXTI_BOOL

	// Edges indicate multiple IRQs generated by physical edges
	static int risingEdges[MAX_EXTI_CNT];
	static int fallingEdges[MAX_EXTI_CNT];

	// Edge indicate a single debounced edge event
	static bool risingEdge[MAX_EXTI_CNT];
	static bool fallingEdge[MAX_EXTI_CNT];

	static int risingCycles[MAX_EXTI_CNT];
	static int fallingCycles[MAX_EXTI_CNT];

	void setRisingCycles(int extiIdx)	{	risingCycles[extiIdx]++;		}
	void setFallingCycles(int extiIdx)	{	fallingCycles[extiIdx]++;	}
	void clrRisingCycles(int extiIdx)	{	risingCycles[extiIdx]  = 0;	}
	void clrFallingCycles(int extiIdx)	{	fallingCycles[extiIdx] = 0;	}
	int getRisingCycles(int extiIdx)	{    return risingCycles[extiIdx];}
	int getFallingCycles(int extiIdx)	{    return fallingCycles[extiIdx];}

	void setRisingEdge(int extiIdx)		{	risingEdge[extiIdx]  = true;		}
	void setFallingEdge(int extiIdx)	{	fallingEdge[extiIdx] = true;		}
	void clrRisingEdge(int extiIdx)		{	risingEdge[extiIdx]  = false;		}
	void clrFallingEdge(int extiIdx)	{	fallingEdge[extiIdx] = false;		}
	bool getRisingEdge(int extiIdx)		{    return risingEdge[extiIdx];}
	bool getFallingEdge(int extiIdx)	{    return fallingEdge[extiIdx];}

	void setRisingEdges(int extiIdx)	{	risingEdges[extiIdx]++;		}
	void setFallingEdges(int extiIdx)	{	fallingEdges[extiIdx]++;	}
	void clrRisingEdges(int extiIdx)	{	risingEdges[extiIdx]  = 0;	}
	void clrFallingEdges(int extiIdx)	{	fallingEdges[extiIdx] = 0;	}
	int getRisingEdges(int extiIdx)		{    return risingEdges[extiIdx];}
	int getFallingEdges(int extiIdx)	{    return fallingEdges[extiIdx];}

#endif //  EXTI_BOOL


void setPinLO(GPIO_TypeDef * GPIOx, int Pin)	{	SET_BIT(GPIOx->BSRR, (0x1U << Pin));				}
void clrPinLO(GPIO_TypeDef * GPIOx, int Pin)	{	SET_BIT(GPIOx->BSRR, (0x1U << (Pin+16)));		}
bool getPinLO(GPIO_TypeDef * GPIOx, int Pin)	{	return READ_BIT(GPIOx->IDR, (0x1U << Pin)) != 0;	}


#ifdef GENERAL_PULLUD_FUNC


/*
 * setting pins as inputs, then setting pull up/down
 *
 * */
bool initPullLO(GPIO_TypeDef * GPIOx, int Pin, bool up)
{
	//	MODE0 = 0
	//	MODE1 = 0
	// 		... input
	//	CNF0 = 1
	//	CNF1 = 0
	//		... floating input
	//	CNF0 = 0
	//	CNF1 = 1
	//		... pull up/down

	bool retval = false;
		if( 0 <= Pin && Pin <= 7 )						// CRL
		{	int gpioCrlModeX_0 = (0x1U << (Pin * 4U));
			int gpioCrlModeX_1 = (0x2U << (Pin * 4U));
			CLEAR_BIT(GPIOx->CRL, gpioCrlModeX_0 );		// input
			CLEAR_BIT(GPIOx->CRL, gpioCrlModeX_1 );

			int gpioCrlCnfX_0 = (0x1U << (2U + Pin*4U));
			int gpioCrlCnfX_1 = (0x2U << (2U + Pin*4U));
			CLEAR_BIT(GPIOx->CRL, gpioCrlCnfX_0);		// pull up/down
			SET_BIT(GPIOx->CRL, gpioCrlCnfX_1);

			retval = true;
		}else
		if( 8 <= Pin && Pin <= 15 )						// CRH
		{	int gpioCrhModeX_0 = (0x1U << ( (Pin-8)* 4U));
			int gpioCrhModeX_1 = (0x2U << ( (Pin-8)* 4U));
			CLEAR_BIT(GPIOx->CRH, gpioCrhModeX_0 );		// input
			CLEAR_BIT(GPIOx->CRH, gpioCrhModeX_1 );

			int gpioCrhCnfX_0 = (0x1U << (2U + (Pin-8)*4U));
			int gpioCrhCnfX_1 = (0x2U << (2U + (Pin-8)*4U));
			CLEAR_BIT(GPIOx->CRH, gpioCrhCnfX_0);		// pull up/down
			SET_BIT(GPIOx->CRH, gpioCrhCnfX_1);

			retval = true;
		}
		else return false;

		//	GPIOx->ODR[x] = 1; // pullup
		//	GPIOx->ODR[x] = 0; // pulldown
		if(up)
			// setPortPin(GPIOx, Pin);
			SET_BIT(GPIOx->ODR, (0x1U << Pin)); 		// pullup
		else
			// clrPortPin(GPIOx, Pin);
			CLEAR_BIT(GPIOx->ODR, (0x1U << Pin)); 	// pulldown
		retval = true;

	return retval;
}


/*
 * deactivate pull-resistors
 *
 * */
bool deinitPullLO(GPIO_TypeDef * GPIOx, int Pin)
{
	//	CNF0 = 1
	//	CNF1 = 0
	//		... floating input

	bool retval = false;
		if( 0 <= Pin && Pin <= 7 )						// CRL
		{
			int gpioCrlCnfX_0 = (0x1U << (2U + Pin*4U));
			int gpioCrlCnfX_1 = (0x2U << (2U + Pin*4U));
			SET_BIT(GPIOx->CRL, gpioCrlCnfX_0);		// floating
			CLEAR_BIT(GPIOx->CRL, gpioCrlCnfX_1);

			retval = true;
		}else
		if( 8 <= Pin && Pin <= 15 )						// CRH
		{
			int gpioCrhCnfX_0 = (0x1U << (2U + (Pin-8)*4U));
			int gpioCrhCnfX_1 = (0x2U << (2U + (Pin-8)*4U));
			SET_BIT(GPIOx->CRH, gpioCrhCnfX_0);		// floating
			CLEAR_BIT(GPIOx->CRH, gpioCrhCnfX_1);

			retval = true;
		}
		else return false;

		retval = true;

	return retval;
}


/*
 *  true if Pin is an input, false otherwise
 * */
bool getIoDirectionLO(GPIO_TypeDef * GPIOx, int Pin)
{	bool mode0 = true,
		 mode1 = true;

	if( 0 <= Pin && Pin <= 7 )						// CRL
	{	int gpioCrlModeX_0 = (0x1U << (Pin * 4U));
		int gpioCrlModeX_1 = (0x2U << (Pin * 4U));
		mode0 = READ_BIT(GPIOx->CRL, gpioCrlModeX_0 );
		mode1 = READ_BIT(GPIOx->CRL, gpioCrlModeX_1 );

	}else
	if( 8 <= Pin && Pin <= 15 )						// CRH
	{	int gpioCrhModeX_0 = (0x1U << ( (Pin-8)* 4U));
		int gpioCrhModeX_1 = (0x2U << ( (Pin-8)* 4U));
		mode0 = READ_BIT(GPIOx->CRH, gpioCrhModeX_0 );
		mode1 = READ_BIT(GPIOx->CRH, gpioCrhModeX_1 );
	}
	return ( !mode0 && !mode1 );
}


PullState getPullStateLO(GPIO_TypeDef * GPIOx, int Pin)
{	PullState state = -1;
	//	MODE0 = 0
	//	MODE1 = 0
	// 		... input
	//	CNF0 = 1
	//	CNF1 = 0
	//		... floating input
	//	CNF0 = 0
	//	CNF1 = 1
	//		... pull up/down

	bool mode0 = false,
		 mode1 = false,
		 cnf0 = false,
		 cnf1 = false;

	if( 0 <= Pin && Pin <= 7 )						// CRL
	{	int gpioCrlModeX_0 = (0x1U << (Pin * 4U));
		int gpioCrlModeX_1 = (0x2U << (Pin * 4U));
		mode0 = READ_BIT(GPIOx->CRL, gpioCrlModeX_0 );		// input
		mode1 = READ_BIT(GPIOx->CRL, gpioCrlModeX_1 );

		int gpioCrlCnfX_0 = (0x1U << (2U + Pin*4U));
		int gpioCrlCnfX_1 = (0x2U << (2U + Pin*4U));
		cnf0 = READ_BIT(GPIOx->CRL, gpioCrlCnfX_0);		// pull up/down
		cnf1 = READ_BIT(GPIOx->CRL, gpioCrlCnfX_1);

	}else
	if( 8 <= Pin && Pin <= 15 )						// CRH
	{	int gpioCrhModeX_0 = (0x1U << ( (Pin-8)* 4U));
		int gpioCrhModeX_1 = (0x2U << ( (Pin-8)* 4U));
		mode0 = READ_BIT(GPIOx->CRH, gpioCrhModeX_0 );		// input
		mode1 = READ_BIT(GPIOx->CRH, gpioCrhModeX_1 );

		int gpioCrhCnfX_0 = (0x1U << (2U + (Pin-8)*4U));
		int gpioCrhCnfX_1 = (0x2U << (2U + (Pin-8)*4U));
		cnf0 = READ_BIT(GPIOx->CRH, gpioCrhCnfX_0);		// pull up/down
		cnf1 = READ_BIT(GPIOx->CRH, gpioCrhCnfX_1);

	}

	if( !mode0 && !mode1 && !cnf0 && cnf1)	// input and pull-mode
	{
		// if(	getPortPin(GPIOx, Pin) ) ... nope, because reads IDR, but we need ODR here
		if(	READ_BIT(GPIOx->ODR, (0x1U << Pin)))	// pullup
			state = PULLUP ;
		else							// pulldown
			state = PULLDOWN ;
	}
	if( !mode0 && !mode1 && cnf0 && !cnf1)	// floating input -> no pulls
		state = NOPULL;

	return  state;
}


gpioPin getGpioPinFromPortPin(char port, int pinNr)
{
	gpioPin gpiopin;
	gpiopin.pinNr = -1;
	gpiopin.GPIOx = 0;

	if( !( 'A' == port || 'B' == port || 'C' == port	) )
		return gpiopin;	// stop this nonsense here and now

	if('A' == port && (0 <= pinNr && pinNr <= 15) )
	{	gpiopin.pinNr = pinNr;
		if(pinNr <= 7)
			gpiopin.GPIOx = GPIOA;
		else
			gpiopin.GPIOx = GPIOB;
	}

	if('B' == port && 0 == pinNr)
	{	gpiopin.GPIOx = GPIOA;
		gpiopin.pinNr = 9;
	}

	if('B' == port && 1 == pinNr)
	{	gpiopin.GPIOx = GPIOA;
		gpiopin.pinNr = 10;
	}

	if('C' == port && 0 == pinNr)
	{	gpiopin.GPIOx = GPIOA;
		gpiopin.pinNr = 8;
	}

	if('C' == port && 1 == pinNr)
	{	gpiopin.GPIOx = GPIOB;
		gpiopin.pinNr = 7;
	}

	return gpiopin;
}

#endif // GENERAL_PULLUD_FUNC



/*
In output mode, CNFy:
00: General purpose output push-pull

MODEy[1:0]
	01: Output mode, max speed 10 MHz.
	10: Output mode, max speed 2 MHz.
	11: Output mode, max speed 50 MHz.

*/

bool initOutput(char port,  int Pin)
{	gpioPin pin = getGpioPinFromPortPin(port, Pin);
	return initOutputLO(pin.GPIOx, pin.pinNr);
}

bool initInput(char port, int Pin)
{	gpioPin pin = getGpioPinFromPortPin(port, Pin);
	return initInputLO(pin.GPIOx, pin.pinNr);
}

bool initPull(char port, int Pin, bool up)
{	gpioPin pin = getGpioPinFromPortPin(port, Pin);
	return initPullLO(pin.GPIOx, pin.pinNr, up);
}

bool deinitPull(char port, int Pin)
{	gpioPin pin = getGpioPinFromPortPin(port, Pin);
	return deinitPullLO(pin.GPIOx, pin.pinNr);
}


bool initOutputLO(GPIO_TypeDef * GPIOx, int Pin)
{	bool retval = false;



	if( 0 <= Pin && Pin <= 7 )						// CRL
	{	int gpioCrlModeX_0 = (0x1U << (Pin * 4U));
		int gpioCrlModeX_1 = (0x2U << (Pin * 4U));
		CLEAR_BIT(GPIOx->CRL, gpioCrlModeX_0 );		// low speed
		SET_BIT(GPIOx->CRL, gpioCrlModeX_1 );

		int gpioCrlCnfX_0 = (0x1U << (2U + Pin*4U));
		int gpioCrlCnfX_1 = (0x2U << (2U + Pin*4U));
		CLEAR_BIT(GPIOx->CRL, gpioCrlCnfX_0);		// output
		CLEAR_BIT(GPIOx->CRL, gpioCrlCnfX_1);

		retval = true;
	}else
	if( 8 <= Pin && Pin <= 15 )						// CRH
	{	int gpioCrhModeX_0 = (0x1U << ( (Pin-8)* 4U));
		int gpioCrhModeX_1 = (0x2U << ( (Pin-8)* 4U));
		CLEAR_BIT(GPIOx->CRH, gpioCrhModeX_0 );		// low speed
		SET_BIT(GPIOx->CRH, gpioCrhModeX_1 );

		int gpioCrhCnfX_0 = (0x1U << (2U + (Pin-8)*4U));
		int gpioCrhCnfX_1 = (0x2U << (2U + (Pin-8)*4U));
		CLEAR_BIT(GPIOx->CRH, gpioCrhCnfX_0);		// output
		CLEAR_BIT(GPIOx->CRH, gpioCrhCnfX_1);

		retval = true;
	}

	return retval;
}



bool initInputLO(GPIO_TypeDef * GPIOx, int Pin)
{
	//	MODE1 = 0
	//	MODE0 = 0
	// 		... input
	bool retval = false;
		if( 0 <= Pin && Pin <= 7 )						// CRL
		{	int gpioCrlModeX_0 = (0x1U << (Pin * 4U));
			int gpioCrlModeX_1 = (0x2U << (Pin * 4U));
			CLEAR_BIT(GPIOx->CRL, gpioCrlModeX_0 );		// input
			CLEAR_BIT(GPIOx->CRL, gpioCrlModeX_1 );
			retval = true;
		}else
		if( 8 <= Pin && Pin <= 15 )						// CRH
		{	int gpioCrhModeX_0 = (0x1U << ( (Pin-8)* 4U));
			int gpioCrhModeX_1 = (0x2U << ( (Pin-8)* 4U));
			CLEAR_BIT(GPIOx->CRH, gpioCrhModeX_0 );		// input
			CLEAR_BIT(GPIOx->CRH, gpioCrhModeX_1 );
			retval = true;
		}
		else return false;
		retval = deinitPullLO(GPIOx, Pin);

	return retval;
}


void setPort(int port, int Pin)
{	if(1 == port)
	{	if( 0 <= Pin && Pin <= 7 )
			setPinLO(GPIOA, Pin);
		if( 8 <= Pin && Pin <= 15 )
			setPinLO(GPIOB, Pin);
	}

	// GPIOA9 => PortB0
	// GPIOA10 => PortB1
	if('B' == port)
	{	if ( 0 == Pin )
			setPinLO(GPIOA, 9);
		if ( 1 == Pin )
			setPinLO(GPIOA, 10);
	}

	// GPIOA8 => PortC0
	// GPIOB7 => PortC1
	if('C' == port)
	{	if ( 0 == Pin )
			setPinLO(GPIOA, 8);
		if ( 1 == Pin )
			setPinLO(GPIOB, 7);
	}

}

void clrPort(int Port, int Pin)
{	if(1 == Port)
	{	if( 0 <= Pin && Pin <= 7 )
			clrPinLO(GPIOA, Pin);
		if( 8 <= Pin && Pin <= 15 )
			clrPinLO(GPIOB, Pin);
	}

	// GPIOA9 => PortB0
	// GPIOA10 => PortB1
	if('B' == Port)
	{
		if ( 0 == Pin )
			clrPinLO(GPIOA, 9);
		if ( 1 == Pin )
			clrPinLO(GPIOA, 10);
	}


	// GPIOA8 => PortC0
	// GPIOB7 => PortC1
	if('C' == Port)
	{
		if ( 0 == Pin )
			clrPinLO(GPIOA, 8);
		if ( 1 == Pin )
			clrPinLO(GPIOB, 7);
	}


}

bool getPort(int Port, int Pin)
{	if(1 == Port)
	{	if( 0 <= Pin && Pin <= 7 )
			return getPinLO(GPIOA, Pin);
		if( 8 <= Pin && Pin <= 15 )
			return getPinLO(GPIOB, Pin);
	}


	// GPIOA9 => PortB0
	// GPIOA10 => PortB1
	if('B' == Port)
	{	if ( 0 == Pin )
			return getPinLO(GPIOA, 9);
		if ( 1 == Pin )
			return getPinLO(GPIOA, 10);
	}

	// GPIOA8 => PortC0
	// GPIOB7 => PortC1
	if('C' == Port)
	{	if ( 0 == Pin )
			return getPinLO(GPIOA, 8);
		if ( 1 == Pin )
			return getPinLO(GPIOB, 7);
	}

	return false;
}


void setPin(char Port, int Pin)
{
	gpioPin pin = getGpioPinFromPortPin(Port, Pin);
	setPinLO(pin.GPIOx, pin.pinNr);
}

void clrPin(char Port, int Pin)
{
	gpioPin pin = getGpioPinFromPortPin(Port, Pin);
	clrPinLO(pin.GPIOx, pin.pinNr);
}

bool getPin(char Port, int Pin)
{	gpioPin pin = getGpioPinFromPortPin(Port, Pin);
	return getPinLO(pin.GPIOx, pin.pinNr);
}



#ifdef GENERAL_INITIRQ_FUNC

bool initExtIrq(char port, int pinNr, bool risingEdge, bool fallingEdge)
{	gpioPin pin = getGpioPinFromPortPin(port, pinNr);
	return	initExtIrqLO(pin.GPIOx, pin.pinNr, risingEdge, fallingEdge);
}

void deinitExtIrq(char port, int pinNr)
{	gpioPin pin = getGpioPinFromPortPin(port, pinNr);
	deinitExtIrqLO(pin.GPIOx, pin.pinNr);
}

bool getIoDirection(char port, int pinNr)
{	gpioPin pin = getGpioPinFromPortPin(port, pinNr);
	return getIoDirectionLO(pin.GPIOx, pin.pinNr);
}

PullState getPullState(char port, int pinNr)
{	gpioPin pin = getGpioPinFromPortPin(port, pinNr);
	return getPullStateLO(pin.GPIOx, pin.pinNr);
}


IrqState getExtIrqState(char port, int pinNr)
{	gpioPin pin = getGpioPinFromPortPin(port, pinNr);
	return getExtIrqStateLO(pin.GPIOx, pin.pinNr);
}

IRQn_Type getExtiIdx(int exti)
{
	if (0 == exti)
		return	EXTI0_IRQn;
	else
	if (1 == exti)
		return	EXTI1_IRQn;
	else
	if (2 == exti)
		return	EXTI2_IRQn;
	else
	if (3 == exti)
		return	EXTI3_IRQn;
	else
	if (4 == exti)
		return	EXTI4_IRQn;
	else
	if ( 5 <= exti &&  exti  <= 9)
		return	EXTI9_5_IRQn;
	else
	if ( 10 <= exti &&  exti  <= 15)
		return	EXTI15_10_IRQn;
	else
		return false;
}


int getExtiCrIdx(int exti)
{	if ( 0 <= exti &&  exti  <= 3)
		return 1 - 1;
	if ( 4 <= exti &&  exti  <= 7)
		return 2 - 1;
	if ( 8 <= exti &&  exti  <= 11)
		return 3 - 1;
	if ( 12 <= exti &&  exti  <= 15)
		return 4 - 1;
	return false;
}

int getExtiCrPxIdx(int exti)
{	int extiCrPxIdx = false;
	switch(exti)
	{
		case 0 : extiCrPxIdx = AFIO_EXTICR1_EXTI0     ; break;
		case 1 : extiCrPxIdx = AFIO_EXTICR1_EXTI1     ; break;
		case 2 : extiCrPxIdx = AFIO_EXTICR1_EXTI2     ; break;
		case 3 : extiCrPxIdx = AFIO_EXTICR1_EXTI3     ; break;
		case 4 : extiCrPxIdx = AFIO_EXTICR2_EXTI4     ; break;
		case 5 : extiCrPxIdx = AFIO_EXTICR2_EXTI5     ; break;
		case 6 : extiCrPxIdx = AFIO_EXTICR2_EXTI6     ; break;
		case 7 : extiCrPxIdx = AFIO_EXTICR2_EXTI7     ; break;
		case 8 : extiCrPxIdx = AFIO_EXTICR3_EXTI8     ; break;
		case 9 : extiCrPxIdx = AFIO_EXTICR3_EXTI9     ; break;
		case 10: extiCrPxIdx = AFIO_EXTICR3_EXTI10    ; break;
		case 11: extiCrPxIdx = AFIO_EXTICR3_EXTI11    ; break;
		case 12: extiCrPxIdx = AFIO_EXTICR4_EXTI12    ; break;
		case 13: extiCrPxIdx = AFIO_EXTICR4_EXTI13    ; break;
		case 14: extiCrPxIdx = AFIO_EXTICR4_EXTI14    ; break;
		case 15: extiCrPxIdx = AFIO_EXTICR4_EXTI15	; break;
		default: extiCrPxIdx = false;
	}
	return extiCrPxIdx;
}


int getExtiCrPBIdx(int exti)
{	volatile int extiCrPxIdx = false;
	switch(exti)
	{
		case 0 : extiCrPxIdx = AFIO_EXTICR1_EXTI0_PB     ; break;
		case 1 : extiCrPxIdx = AFIO_EXTICR1_EXTI1_PB     ; break;
		case 2 : extiCrPxIdx = AFIO_EXTICR1_EXTI2_PB     ; break;
		case 3 : extiCrPxIdx = AFIO_EXTICR1_EXTI3_PB     ; break;
		case 4 : extiCrPxIdx = AFIO_EXTICR2_EXTI4_PB     ; break;
		case 5 : extiCrPxIdx = AFIO_EXTICR2_EXTI5_PB     ; break;
		case 6 : extiCrPxIdx = AFIO_EXTICR2_EXTI6_PB     ; break;
		case 7 : extiCrPxIdx = AFIO_EXTICR2_EXTI7_PB     ; break;
		case 8 : extiCrPxIdx = AFIO_EXTICR3_EXTI8_PB     ; break;
		case 9 : extiCrPxIdx = AFIO_EXTICR3_EXTI9_PB     ; break;
		case 10: extiCrPxIdx = AFIO_EXTICR3_EXTI10_PB    ; break;
		case 11: extiCrPxIdx = AFIO_EXTICR3_EXTI11_PB    ; break;
		case 12: extiCrPxIdx = AFIO_EXTICR4_EXTI12_PB    ; break;
		case 13: extiCrPxIdx = AFIO_EXTICR4_EXTI13_PB    ; break;
		case 14: extiCrPxIdx = AFIO_EXTICR4_EXTI14_PB    ; break;
		case 15: extiCrPxIdx = AFIO_EXTICR4_EXTI15_PB	; break;
		default: extiCrPxIdx = false;
	}
	return extiCrPxIdx;
}




#if 0
		/**
		 * lowLEvel init, only check for Clocks, activate in EXTI and the vecotr and register the ISR
		 * rest inits regarding Pins (input, pullup) in a highger function
		 */
		bool initExtIrqLO(GPIO_TypeDef * GPIOx, int Pin);

		bool initExtIrqLO(GPIO_TypeDef * GPIOx, int Pin)
		{	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPBEN + RCC_APB2ENR_AFIOEN);	// Enable clock for Port B and alternate functions
			MODIFY_REG(AFIO->EXTICR[?2-1], AFIO_EXTICR?2_EXTIx, AFIO_EXTICR?2_EXTIx_Px);		// Assign PBx with rising edge to EXTIx
			if( 0 <= Pin && Pin <= 7 )					// CRL
			else return false;

			SET_BIT(EXTI->IMR, EXTI_IMR_MRx);			// activate irq event mask, actually Pin may be IRQ 0 ... 18
			SET_BIT(EXTI->RTSR, EXTI_RTSR_TRx);			// activate rising edge     actually Pin may be IRQ 0 ... 18
			SET_BIT(EXTI->FTSR, EXTI_FTSR_TRx);			// activate falling edge    actually Pin may be IRQ 0 ... 18

			NVIC_EnableIRQ(EXTIx_x_IRQn);				// Enable the interrupt handler call
			SET_BIT(EXTI->PR, EXTI_PR_PRx);				// Clear pending interrupt flag
		}

#endif



bool initExtIrqLO(GPIO_TypeDef * GPIOx, int Pin, bool risingEdge, bool fallingEdge){
	if (!risingEdge && !fallingEdge)	// that wouldn't make any sense, so:
		return false;

	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPBEN + RCC_APB2ENR_AFIOEN);				// Enable clock for Port B and alternate functions
	volatile int CrIdx   = getExtiCrIdx(Pin);
	volatile int CrPxIdx = getExtiCrPxIdx(Pin);
	volatile int CrPBIdx = getExtiCrPBIdx(Pin);

	// Assign PinY on GPIOx to EXTIy
	if( GPIOA == GPIOx )
	{	MODIFY_REG(AFIO->EXTICR[CrIdx], CrPxIdx, 0x00000000);
	}else
	if( GPIOB == GPIOx )
	{	MODIFY_REG(AFIO->EXTICR[CrIdx], CrPxIdx, CrPBIdx);
	}
	else return false;

	if ( ! initPullLO(GPIOx, Pin, false))					// by default a pulldown
		return false;

	SET_BIT(EXTI->IMR, EXTI_IMR_MRx(Pin));				// activate irq event mask, actually Pin may be IRQ 0 ... 18

	if (risingEdge)
		SET_BIT(EXTI->RTSR, EXTI_RTSR_TRx(Pin));			// activate rising edge     actually Pin may be IRQ 0 ... 18
	if (fallingEdge)
		SET_BIT(EXTI->FTSR, EXTI_FTSR_TRx(Pin));			// activate falling edge    actually Pin may be IRQ 0 ... 18


	volatile IRQn_Type irq =  getExtiIdx(Pin);
	NVIC_EnableIRQ( irq );								// Enable the interrupt handler call

	#define EXTI_PR_PRx(x)	(0x1U << x)

	SET_BIT(EXTI->PR, EXTI_PR_PRx(Pin));				// Clear pending interrupt flag

	clrFallingEdges(Pin);
	clrRisingEdges(Pin);

	return (	NVIC_GetActive(EXTI_PR_PRx(Pin))
			&&  SET_BIT(EXTI->IMR, EXTI_IMR_MRx(Pin))	);
}

void deinitExtIrqLO(GPIO_TypeDef * GPIOx, int Pin)
{
	// ? Clear pending interrupt flag

	// disable according IRQ
	volatile IRQn_Type irq =  getExtiIdx(Pin);
	NVIC_DisableIRQ( irq );								// Disable the interrupt handler call

	// clear alternate function entry, deAssign PinY on GPIOx to EXTIy
//	volatile int CrIdx   = getExtiCrIdx(Pin);
//	volatile int CrPxIdx = getExtiCrPxIdx(Pin);
//	volatile int CrPBIdx = getExtiCrPBIdx(Pin);
//	if( GPIOA == GPIOx )
//	{	MODIFY_REG(AFIO->EXTICR[CrIdx], 0x00000000, CrPxIdx);
//	}else
//	if( GPIOB == GPIOx )
//	{	MODIFY_REG(AFIO->EXTICR[CrIdx], CrPBIdx, CrPxIdx);
//	}
//	else return;

	// clear EXTI entries
	CLEAR_BIT(EXTI->IMR, EXTI_IMR_MRx(Pin));			// deactivate irq event mask
	CLEAR_BIT(EXTI->RTSR, EXTI_RTSR_TRx(Pin));			// deactivate rising edge
	CLEAR_BIT(EXTI->FTSR, EXTI_FTSR_TRx(Pin));			// deactivate falling edge


	clrFallingEdges(Pin);
	clrRisingEdges(Pin);
}


IrqState	getExtIrqStateLO(GPIO_TypeDef * GPIOx, int Pin)
{
	if( !READ_BIT(EXTI->IMR, EXTI_IMR_MRx(Pin))	)
		return NOIRQ;

	if( READ_BIT(EXTI->RTSR, EXTI_RTSR_TRx(Pin)) &&	READ_BIT(EXTI->FTSR, EXTI_FTSR_TRx(Pin)) )
		return RISE_FALL_EDGE;

	if( READ_BIT(EXTI->RTSR, EXTI_RTSR_TRx(Pin)) &&	!READ_BIT(EXTI->FTSR, EXTI_FTSR_TRx(Pin)) )
		return RISING_EDGE;

	if( !READ_BIT(EXTI->RTSR, EXTI_RTSR_TRx(Pin)) &&	READ_BIT(EXTI->FTSR, EXTI_FTSR_TRx(Pin)) )
		return FALLING_EDGE;

	return -1;
}



bool setA7PullUp()
{
	// copypasta von B5 pullup
//	SET_BIT(GPIOB->ODR, GPIO_ODR_ODR5);	// Set ODR-Bit high
//	SET_BIT(GPIOB->CRL, GPIO_CRL_CNF5_1);	// and CNF for pullup
//	CLEAR_BIT(GPIOB->CRL, GPIO_CRL_CNF5_0);

	// output
	MODIFY_REG(GPIOA->CRL, 0,GPIO_CRL_MODE7_0 + GPIO_CRL_MODE7_1);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE7_0 + GPIO_CRL_MODE7_1, 0);

	//	MODE1 = 0
	//	MODE0 = 0
	// 		... input
	CLEAR_BIT(GPIOA->CRL, GPIO_CRL_MODE7_0 );
	CLEAR_BIT(GPIOA->CRL, GPIO_CRL_MODE7_1 );

	//	CNF1 = 0
	//	CNF0 = 1
	//		... floating input
	//	CNF1 = 1
	//	CNF0 = 0
	//		... pull up/down
	CLEAR_BIT(GPIOA->CRL, GPIO_CRL_CNF7_0);
	SET_BIT(GPIOA->CRL, GPIO_CRL_CNF7_1);

//	GPIOA->ODR[7-1] = 0; // pulldown
//	GPIOA->ODR[7-1] = 1; // pullup

	SET_BIT(GPIOA->ODR, GPIO_ODR_ODR7); // pullup
	return true;
}


#endif // GENERAL_INITIRQ_FUNC


//	EXTI0_IRQHandler(){};
//	EXTI1_IRQHandler(){};
//	EXTI2_IRQHandler(){};
//	EXTI3_IRQHandler(){};
void EXTI4_IRQHandler()
{
	if ((EXTI->PR & EXTI_PR_PR4) == EXTI_PR_PR4)  /* Check if line 4 has triggered the IRQ */
	{	SET_BIT(EXTI->PR, EXTI_PR_PR4);			/* Clear the pending bit */
		if(getPinLO(GPIOA, 4))
			setRisingEdges(4);
    	if(!getPinLO(GPIOA, 4))
    		setFallingEdges(4);
	}
}

void EXTI9_5_IRQHandler()
{
    if ((EXTI->PR & EXTI_PR_PR5) == EXTI_PR_PR5)  /* Check line 5 has triggered the IRQ */
    {	SET_BIT(EXTI->PR, EXTI_PR_PR5);			/* Clear the pending bit */
			if(getPinLO(GPIOA, 5))		// could also be by GPIOB5, but thats occupied by TimerB/TIM3
				setRisingEdges(5);
	    	if(!getPinLO(GPIOA, 5))
	    		setFallingEdges(5);


    }

    if ((EXTI->PR & EXTI_PR_PR6) == EXTI_PR_PR6)	/* Check line 6 has triggered the IRQ */
    {	SET_BIT(EXTI->PR, EXTI_PR_PR6);				/* Clear the pending bit */
    	// delay_ms(10);	...nope, first off bad design, also, in irq context, systick doesnt increase, so this freezes here.
    	if(getPinLO(GPIOA, 6))		// could also be by GPIOB6, but thats occupied by TimerC
    	{	setRisingEdges(6);
    	}
    	if( !getPinLO(GPIOA, 6) )
    	{	setFallingEdges(6);
    	}
    }

    if ((EXTI->PR & EXTI_PR_PR7) == EXTI_PR_PR7)	/* Check line 7 has triggered the IRQ */
    {	SET_BIT(EXTI->PR, EXTI_PR_PR7);				/* Clear the pending bit */
    	// delay_ms(10);	...nope, first off bad design, also, in irq context, systick doesnt increase, so this freezes here.
    	if(getPinLO(GPIOA, 7))		// could also be by GPIOB7, but thats occupied by output PortC1
    	{	setRisingEdges(7);
    	}
    	if( !getPinLO(GPIOA, 7) )
    	{	setFallingEdges(7);
    	}
    }

    if ((EXTI->PR & EXTI_PR_PR8) == EXTI_PR_PR8)  /* Check line 8 has triggered the IRQ */
    {	SET_BIT(EXTI->PR, EXTI_PR_PR8);			/* Clear the pending bit */
			if(getPinLO(GPIOB, 8))		// could also be by GPIOA8, but thats occupied by output PortC0
				setRisingEdges(8);
	    	if(!getPinLO(GPIOA, 8))
	    		setFallingEdges(8);

    }


    if ((EXTI->PR & EXTI_PR_PR9) == EXTI_PR_PR9)	/* Check line 9 has triggered the IRQ */
    {	SET_BIT(EXTI->PR, EXTI_PR_PR9);				/* Clear the pending bit */
    	// delay_ms(10);	...nope, first off bad design, also, in irq context, systick doesnt increase, so this freezes here.
    	if(getPinLO(GPIOA, 9))
    	{	setRisingEdges(9);
    	}
    	if( !getPinLO(GPIOA, 9) )
    	{	setFallingEdges(9);
    	}
    }

    // Output a trace message
    // TODO: ITM_SendStr("irq 5...9\n");
}



void EXTI15_10_IRQHandler()
{
    if ((EXTI->PR & EXTI_PR_PR10) == EXTI_PR_PR10)  /* Check line 10 has triggered the IRQ */
    {	SET_BIT(EXTI->PR, EXTI_PR_PR10);			/* Clear the pending bit */
    	if(getPinLO(GPIOA, 10))
    	{	setRisingEdges(10);
    	}
		if( !getPinLO(GPIOA, 10) )
    	{	setFallingEdges(10);
    	}
    }


    if ((EXTI->PR & EXTI_PR_PR12) == EXTI_PR_PR12)  /* Check line 12 has triggered the IRQ */
    {	SET_BIT(EXTI->PR, EXTI_PR_PR12);			/* Clear the pending bit */
		setRisingEdges(12);
		setFallingEdges(12);
    }



    //  if ((EXTI->PR & EXTI_PR_PR13) == EXTI_PR_PR13)  /* Check line 1 has triggered the IRQ */
	//  {	SET_BIT(EXTI->PR, EXTI_PR_PR13);			/* Clear the pending bit */
	//  	startSwitchPressed = true;
	//  }
	//  if ((EXTI->PR & EXTI_PR_PR14) == EXTI_PR_PR14)  /* Check line 1 has triggered the IRQ */
	//  {	SET_BIT(EXTI->PR, EXTI_PR_PR14);			/* Clear the pending bit */
	//     	timeSwitchPressed = true;
	//  }
	//  if ((EXTI->PR & EXTI_PR_PR15) == EXTI_PR_PR15)  /* Check line 1 has triggered the IRQ */
	//  {	SET_BIT(EXTI->PR, EXTI_PR_PR15);			/* Clear the pending bit */
	//  	intensitySwitchPressed = true;
	//  }

    // Output a trace message
	// TODO: ITM_SendStr("irq 10...15\n");
}



void initDbgLed()	{   MODIFY_REG(GPIOC->CRH, GPIO_CRH_CNF13 + GPIO_CRH_MODE13, GPIO_CRH_MODE13_0);	}
void setDbgLED()	{	WRITE_REG(GPIOC->BSRR, GPIO_BSRR_BS13);	}
void clrDbgLED()	{	WRITE_REG(GPIOC->BSRR, GPIO_BSRR_BR13);	}
// void deinitDbgLed(){}
// bool getDbgLED()		{	return (READ_BIT(GPIOC->IDR, GPIO_IDR_IDR13) != 0);	}

void initRelays()
{

	//	PB0 , 1
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF0 + GPIO_CRL_MODE0, GPIO_CRL_MODE0_0);
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF1 + GPIO_CRL_MODE1, GPIO_CRL_MODE1_0);

	GPIOB->BRR = 0b0000000000000011; // clear PB0 , 1
}

void setRelay0()
{
	SET_BIT(GPIOB->BSRR, GPIO_BSRR_BS0);
}

void clrRelay0()
{	SET_BIT(GPIOB->BRR, GPIO_BRR_BR0);

}

bool getRelay0()
{	return READ_BIT(GPIOB->IDR, GPIO_IDR_IDR0) != 0;
}

void setRelay1()
{	// SET_BIT(GPIOB->ODR, GPIO_ODR_ODR1);
	SET_BIT(GPIOB->BSRR, GPIO_BSRR_BS1);
}

void clrRelay1()
{
	SET_BIT(GPIOB->BRR, GPIO_BRR_BR1);
	// CLEAR_BIT(GPIOB->ODR, GPIO_ODR_ODR1);
}

bool getRelay1()
{	return (READ_BIT(GPIOB->IDR, GPIO_IDR_IDR1) != 0);
}

void deinitRelays()
{
}


// GPIOA8 => PortC0
// GPIOB7 => PortC1

void initPortC()
{
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF8 + GPIO_CRH_MODE8, GPIO_CRH_MODE8_0);
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF7 + GPIO_CRL_MODE7, GPIO_CRL_MODE7_0);
}

void deinitPortC()
{
	//	MODE1 = 0
	//	MODE0 = 0
	// 		... input
	//	CNF1 = 0
	//	CNF0 = 1
	//		... floating input
	CLEAR_BIT(GPIOA->CRH, GPIO_CRH_MODE8_0);
	CLEAR_BIT(GPIOA->CRH, GPIO_CRH_MODE8_1);
	CLEAR_BIT(GPIOA->CRH, GPIO_CRH_CNF8_1);
	SET_BIT(GPIOA->CRH, GPIO_CRH_CNF8_0 );

	CLEAR_BIT(GPIOB->CRL, GPIO_CRL_MODE7_0);
	CLEAR_BIT(GPIOB->CRL, GPIO_CRL_MODE7_1);
	CLEAR_BIT(GPIOB->CRL, GPIO_CRL_CNF7_1);
	SET_BIT(GPIOB->CRL, GPIO_CRL_CNF7_0 );

//	initPortPinInput(GPIOA, 8, false, false);
//	initPortPinInput(GPIOB, 7, false, false);

}



void initPortB()
{
		// GPIOA9 => PortB0
		// GPIOA10 => PortB1
		MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF9  + GPIO_CRH_MODE9,  GPIO_CRH_MODE9_0);
		MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF10 + GPIO_CRH_MODE10, GPIO_CRH_MODE10_0);
}

void deinitPortB()
{
	// reset
	// MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF5 + GPIO_CRL_MODE5, GPIO_CRL_MODE5_0);


}


void initPortA()
{


	//	PA0 ... 7
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF0 + GPIO_CRL_MODE0, GPIO_CRL_MODE0_0);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF1 + GPIO_CRL_MODE1, GPIO_CRL_MODE1_0);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF2 + GPIO_CRL_MODE2, GPIO_CRL_MODE2_0);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF3 + GPIO_CRL_MODE3, GPIO_CRL_MODE3_0);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF4 + GPIO_CRL_MODE4, GPIO_CRL_MODE4_0);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF5 + GPIO_CRL_MODE5, GPIO_CRL_MODE5_0);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF6 + GPIO_CRL_MODE6, GPIO_CRL_MODE6_0);
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF7 + GPIO_CRL_MODE7, GPIO_CRL_MODE7_0);

	// rewiring PA:4 and 5 to GPIOC, to free up GPIOC4 and 5 for DAC
	// PA:4 = PC4
	// PA:5 = PC5
	initOutputLO(GPIOC, 4);
	initOutputLO(GPIOC, 5);

	//	PB8 ... 15
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF8  + GPIO_CRH_MODE8 , GPIO_CRH_MODE8_0 );
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF9  + GPIO_CRH_MODE9 , GPIO_CRH_MODE9_0 );
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF10 + GPIO_CRH_MODE10, GPIO_CRH_MODE10_0);
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF11 + GPIO_CRH_MODE11, GPIO_CRH_MODE11_0);
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF12 + GPIO_CRH_MODE12, GPIO_CRH_MODE12_0);
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF13 + GPIO_CRH_MODE13, GPIO_CRH_MODE13_0);
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF14 + GPIO_CRH_MODE14, GPIO_CRH_MODE14_0);
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_CNF15 + GPIO_CRH_MODE15, GPIO_CRH_MODE15_0);

	GPIOA->BSRR = 0b00000000111111110000000000000000;
	GPIOB->BSRR = 0b11111111000000000000000000000000;
}

void deinitPortA()
{
	// reset
	// MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF5 + GPIO_CRL_MODE5, GPIO_CRL_MODE5_0);


}

// VOUTA = PA4 -> DAC_OUT1
// VOUTB = PA5 -> DAC_OUT2
void initDACs()
{
//	#define naja
	#ifdef naja
		// Enable alternate function clock. Bit 0 in RCC APB2ENR register
		RCC->APB2ENR |= (1 << 0);
		// Enable GPIOD clock. Bit 5 in RCC APB2ENR register
		RCC->APB2ENR |= (1 << 5);
		// Enable GPIOA clock. Bit 2 in RCC APB2ENR register
		RCC->APB2ENR |= (1 << 2);

		// Make PA4 analog input (0b0000)
		GPIOA->CRL &= 0xFFF0FFFF;

	#endif

	SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);	// enable DAC Clock

	SET_BIT(DAC->CR, DAC_CR_EN1);
	SET_BIT(DAC->CR, DAC_CR_EN2);

	// ensure trigger is turned off and holding regs directly pushed to our regs:
	CLEAR_BIT(DAC->CR, DAC_CR_TEN1);
	CLEAR_BIT(DAC->CR, DAC_CR_TEN2);

	// ensure output buffer is on
	CLEAR_BIT(DAC->CR, DAC_CR_BOFF1);
	CLEAR_BIT(DAC->CR, DAC_CR_BOFF2);

	// Configure PA1 as analog input ADC12_IN1
	// MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF1,  0b00 << GPIO_CRL_CNF1_Pos);
	// MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE1, 0b00 << GPIO_CRL_MODE1_Pos);

//	set analog AF-MODE for PA4 and PA5


	// TODO: bit doesnet exist in this proc?
//	#define AFIO_MAPR2_TIM67_DAC_DMA_REMAP (11U)
//	SET_BIT(AFIO->MAPR2, AFIO_MAPR2_TIM67_DAC_DMA_REMAP);



}


void deinitDACs()
{


	initInputLO(GPIOA, 4);
	initInputLO(GPIOA, 5);

	CLEAR_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);	// disable DAC Clock




}

/*
 * @brief		write raw values to DAC
 * @param[in]	channel chooses between CH1 and CH2
 * @param[in]	dacval	value, between 0 and (2^12)-1,
 * 				to be written into the DAC, corresponds with its analouge voltage
 * @return		'true' if correct inputs were supplied, otherwise 'false'.
 *
 */

bool writeDacRaw(int channel, int dacval)
{	if ( 0 <= dacval && dacval <= MAX_DAC_VAL )
	{	if ( 1 == channel )
		{		DAC->DHR12R1 = dacval;
			//	DAC->DOR1;
		}
		else if ( 2 == channel )
		{		DAC->DHR12R2 = dacval;
			//	DAC->DOR2;
		}
		else
			return false;
		return true;
	}else{
		return false;
	}
}


bool writeDacPercent(int channel, float percent)
{
	if ( 0 <= percent && percent <= 100 )
	{	writeDacRaw(channel, percent*(MAX_DAC_VAL)/100.0);
		return true;
	}else	// error case
		return false;
}


int  readDacRaw(int channel)
{	if ( 1 == channel )
		return	DAC->DOR1;
	else if ( 2 == channel )
		return DAC->DOR2;
	else
		return false;
}

float readDacPercent(int channel)
{	return 100.0*readDacRaw(channel)/(MAX_DAC_VAL);
}

bool writeDacVolts(int channel, float voltage)
{
	if ( MIN_DAC_VOLT <= voltage && voltage <= MAX_DAC_VOLT )
	{	writeDacRaw(channel, dacVoltToRaw(voltage));
		return true;
	}else	// error case
		return false;
}

/*
 * @brief	calculate the raw integer equivalent of a given DAC Voltage
 * 			implements y = k*x + d
 * */
int		dacVoltToRaw(float voltage)
{	return	(MAX_DAC_VAL/2 - voltage*MAX_DAC_VAL/(MAX_DAC_VOLT - MIN_DAC_VOLT));
}

/*
 * @brief	calculate the analogue voltage equivalent of a given DAC raw value
 * */
float	dacRawToVolt(int dacval)
{	return - (dacval - MAX_DAC_VAL/2)*(MAX_DAC_VOLT - MIN_DAC_VOLT)/MAX_DAC_VAL;
}

float  readDacVolts(int channel)
{	return	dacRawToVolt(readDacRaw(channel));
}

void initHal()
{
    // Enable clocks for Port A, B and C
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN + RCC_APB2ENR_IOPBEN + RCC_APB2ENR_IOPCEN);

    // Set State LEDs as outputs
    MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF9 + GPIO_CRH_MODE9, GPIO_CRH_MODE9_0);
    MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF10 + GPIO_CRH_MODE10, GPIO_CRH_MODE10_0);

	initDbgLed();
	initRelays();

	//    MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF8 + GPIO_CRH_MODE8, GPIO_CRH_MODE8_0);
	//    MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF5 + GPIO_CRL_MODE5, GPIO_CRL_MODE5_0);

	initPortC();
    initPortB();
    initPortA();


}


void deinitHal()
{
	deinitRelays();
	deinitPortC();
}


